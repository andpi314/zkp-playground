# zkp-playground

A playground to ease understanding of Zero Knowledge Proof

## Circom

A guide to make curcom circuits ready to be used

### Installation

Circom has depcrecated its javascript compiler (which you could install as a NPM package) to be replaced by its newest Rust compiler. The new compiler must be installed thorough the source. Full guide can be found [here](https://docs.circom.io/getting-started/installation/).

Install dependencies:

```bash
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

Install circom from sources:

```bash
git clone https://github.com/iden3/circom.git
```

Enter the downloaded folder and run:

```bash
cargo build --release
cargo install --path circom
```

Now you should have circom installed globally.

### Usage

Crate a `build` folder in the root of the project or change the `circom:build` script in the package.json file, making the -o arguments pointing to a different folder of your choice.

### Example

In order to better understand how pieces glue together I will walk you around a simple toy problem.

#### Writing a circuit

Firstly, we have written a fake hash function in circom file creating our SNARKs function, which is basically a circuit representation of our function.

#### Compiling the circuit

Using the `circom:build` script we can compile the circuit generating three file:

- `--r1cs`: it generates the file multiplier2.r1cs that contains the R1CS constraint system of the circuit in binary format.
- `--wasm`: it generates the directory multiplier2_js that contains the Wasm code (multiplier2.wasm) and other files needed to generate the witness.
- `--sym` : it generates the file multiplier2.sym , a symbols file required for debugging or for printing the constraint system in an annotated mode.
- `--c` : it generates the directory multiplier2_cpp that contains several files (multiplier2.cpp, multiplier2.dat, and other common files for every compiled program like main.cpp, MakeFile, etc) needed to compile the C code to generate the witness.

#### Generate the witness

Before creating the proof, we need to calculate all the signals of the circuit that match all the constraints of the circuit. For that, we will use the `Wasm` module generated by `circom` that helps to do this job.

Firstly we need to crate a file `input.json` that contains the secret input of the circuit. Then, we can run:

```bash
yarn circom:generate:witness
```

The program will generate the a `witness.wtns` file. This file is encoded in a binary format compatible with `snarkjs`, which is the tool that we use to create the actual proofs.

If the generation phase take too long, you may want to use the C++ version of the program. Further advice on how to run it [here](https://docs.circom.io/getting-started/computing-the-witness/#computing-the-witness-with-webassembly).

#### Ceremony for creating proofs

After compiling the circuit and running the witness calculator with an appropriate input, we will have a file with extension `.wtns` that contains all the computed signals and, a file with extension .r1cs that contains the constraints describing the circuit. Both files will be used to create our proof.

In order to create the proof we will firstly need to setup a trusted ceremony. Follow [this guide](https://docs.circom.io/getting-started/proving-circuits/) to make it happen.

You can simply run the `ceremony:setup` script. Please make sure file name and folder structure matches the environment you are working on.

#### Generate a proof

Once the witness is computed and the trusted setup is already executed, we can generate a zk-proof associated to the circuit and the witness:

```bash
yarn zkp:generate
```

This command generates a `Groth16` proof and outputs two files:

- proof.json: it contains the proof.
- public.json: it contains the values of the public inputs and outputs.

#### Verify the proof

To verify the proof, execute the following command:

```bash
zkp:verify
```

A valid proof not only proves that we know a set of signals that satisfy the circuit, but also that the public inputs and outputs that we use match the ones described in the `public.json` file.

Eventually, you can crate a SmartContract to verify the proof. Refer [here](https://docs.circom.io/getting-started/proving-circuits/#verifying-from-a-smart-contract).
